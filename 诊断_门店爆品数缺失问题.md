# 诊断：门店爆品数缺失问题

## ✅ 问题已解决

**实施时间**：2025-12-14
**解决方案**：SmartColumnFinder三层查找机制
**状态**：✅ 已完成并测试通过

---

## 🔍 问题分析（历史记录）

**现象**：对比模式下"门店爆品数"显示为0

**根本原因**：硬编码索引导致列查找失败

**可能原因**：

### 1. 列索引不匹配（最可能）

**当前代码逻辑**（`dashboard_v2.py` 第283行）：
```python
# AB列(索引27): 美团一级分类爆品sku数
if len(category_df.columns) > 27:
    summary['门店爆品数'] = category_df.iloc[:, 27].sum()
```

**问题**：
- 代码期望"爆品数"在第27列（AB列）
- 但实际Excel文件中可能在第23列（X列）或其他位置
- 如果列数不够27列，或者第27列不是爆品数，就会导致该KPI缺失

### 2. 数据为空或NaN

即使列索引正确，如果该列的数据全部为空或NaN，`sum()`会返回0或NaN。

### 3. 数据格式问题

如果该列包含非数值数据（如文本），`sum()`可能会失败或返回0。

---

## 🛠️ 诊断方案

### 方案A：添加调试日志（推荐）

在`get_kpi_summary`方法中添加详细日志：

```python
# 从美团一级分类详细指标中获取门店爆品数和平均折扣
if not self.data['category_l1'].empty:
    category_df = self.data['category_l1']
    
    # 调试日志：打印列数和列名
    logger.info(f"📊 category_l1 列数: {len(category_df.columns)}")
    logger.info(f"📊 category_l1 列名: {category_df.columns.tolist()}")
    
    # AB列(索引27): 美团一级分类爆品sku数
    if len(category_df.columns) > 27:
        burst_value = category_df.iloc[:, 27].sum()
        logger.info(f"🔥 第27列(AB列)爆品数: {burst_value}")
        logger.info(f"🔥 第27列列名: {category_df.columns[27]}")
        summary['门店爆品数'] = burst_value
    else:
        logger.warning(f"⚠️ category_l1列数不足27列，无法获取爆品数")
```

### 方案B：智能列名查找（最佳）

使用列名匹配而不是固定索引：

```python
# 从美团一级分类详细指标中获取门店爆品数
if not self.data['category_l1'].empty:
    category_df = self.data['category_l1']
    
    # 尝试多种可能的列名
    burst_col_names = [
        '美团一级分类爆品sku数',
        '爆品sku数',
        '爆品数',
        'Hot Products'
    ]
    
    burst_col = None
    for col_name in burst_col_names:
        if col_name in category_df.columns:
            burst_col = col_name
            break
    
    if burst_col:
        summary['门店爆品数'] = category_df[burst_col].sum()
        logger.info(f"✅ 找到爆品数列: {burst_col}, 值: {summary['门店爆品数']}")
    else:
        # 尝试按索引查找（兼容旧格式）
        if len(category_df.columns) > 27:
            summary['门店爆品数'] = category_df.iloc[:, 27].sum()
            logger.info(f"✅ 使用索引27获取爆品数: {summary['门店爆品数']}")
        elif len(category_df.columns) > 23:
            summary['门店爆品数'] = category_df.iloc[:, 23].sum()
            logger.info(f"✅ 使用索引23获取爆品数: {summary['门店爆品数']}")
        else:
            logger.warning(f"⚠️ 无法找到爆品数列，列名: {category_df.columns.tolist()}")
```

### 方案C：手动检查Excel文件

1. 打开`reports/本店/XXX_分析报告.xlsx`
2. 查看"美团一级分类详细指标"工作表
3. 找到"爆品sku数"或类似列名
4. 记录该列的位置（如AB列、X列等）
5. 检查该列是否有数据

---

## 💡 推荐修复方案

我建议采用**方案B：智能列名查找**，原因：

1. **兼容性好**：支持多种列名和索引
2. **容错性强**：即使列名或索引变化也能找到数据
3. **可维护性高**：不依赖固定索引
4. **有日志记录**：方便排查问题

---

## 🔧 立即修复代码

让我修改`dashboard_v2.py`中的代码，使用智能列名查找：

### 修改位置

**文件**：`dashboard_v2.py` 第278-284行

### 修改前

```python
# 从美团一级分类详细指标中获取门店爆品数和平均折扣
if not self.data['category_l1'].empty:
    category_df = self.data['category_l1']
    # AB列(索引27): 美团一级分类爆品sku数
    if len(category_df.columns) > 27:
        summary['门店爆品数'] = category_df.iloc[:, 27].sum()
```

### 修改后

```python
# 从美团一级分类详细指标中获取门店爆品数和平均折扣
if not self.data['category_l1'].empty:
    category_df = self.data['category_l1']
    
    # 智能查找爆品数列（支持多种列名和索引）
    burst_col_names = ['美团一级分类爆品sku数', '爆品sku数', '爆品数']
    burst_col = None
    
    # 优先按列名查找
    for col_name in burst_col_names:
        if col_name in category_df.columns:
            burst_col = col_name
            break
    
    if burst_col:
        summary['门店爆品数'] = category_df[burst_col].sum()
        logger.info(f"✅ 找到爆品数列: {burst_col}, 值: {summary['门店爆品数']}")
    else:
        # 按索引查找（兼容旧格式）
        if len(category_df.columns) > 27:
            summary['门店爆品数'] = category_df.iloc[:, 27].sum()
            logger.info(f"✅ 使用索引27获取爆品数: {summary['门店爆品数']}")
        elif len(category_df.columns) > 23:
            summary['门店爆品数'] = category_df.iloc[:, 23].sum()
            logger.info(f"✅ 使用索引23获取爆品数: {summary['门店爆品数']}")
        else:
            logger.warning(f"⚠️ 无法找到爆品数列，列数: {len(category_df.columns)}")
```

---

## 🧪 测试步骤

修复后，请按以下步骤测试：

### 1. 启动Dashboard

```bash
python dashboard_v2.py
```

### 2. 上传数据

- 上传本店原始数据
- 上传竞对原始数据

### 3. 查看日志

在控制台查找以下日志：

```
✅ 找到爆品数列: 美团一级分类爆品sku数, 值: 15
```

或

```
✅ 使用索引27获取爆品数: 15
```

或

```
⚠️ 无法找到爆品数列，列数: 25
```

### 4. 验证单店视图

- 打开"本店数据看板"TAB
- 检查是否显示"门店爆品数"卡片
- 检查数值是否正确

### 5. 验证对比视图

- 开启"对比模式"
- 选择竞对门店
- 检查是否显示"门店爆品数"对比卡片
- 检查数值是否正确（不应该是0）

---

## 📊 预期结果

### 场景1：列名匹配成功

**日志**：
```
✅ 找到爆品数列: 美团一级分类爆品sku数, 值: 15
```

**结果**：
- 单店视图显示"门店爆品数: 15"
- 对比视图显示"本店15 vs 竞对20"

### 场景2：使用索引27成功

**日志**：
```
✅ 使用索引27获取爆品数: 15
```

**结果**：
- 单店视图显示"门店爆品数: 15"
- 对比视图显示"本店15 vs 竞对20"

### 场景3：使用索引23成功（兼容旧格式）

**日志**：
```
✅ 使用索引23获取爆品数: 15
```

**结果**：
- 单店视图显示"门店爆品数: 15"
- 对比视图显示"本店15 vs 竞对20"

### 场景4：无法找到爆品数列

**日志**：
```
⚠️ 无法找到爆品数列，列数: 20
```

**结果**：
- 单店视图不显示"门店爆品数"卡片
- 对比视图不显示"门店爆品数"对比卡片
- 需要检查Excel文件格式

---

## 🔍 进一步排查

如果修复后仍然无法显示，请提供以下信息：

1. **日志输出**：控制台中关于爆品数的日志
2. **Excel列名**：`category_l1`工作表的所有列名
3. **列数**：`category_l1`工作表的总列数
4. **数据示例**：爆品数列的前几行数据

---

## 📝 总结

"门店爆品数"缺失的根本原因是**列索引硬编码**，导致：

1. 当Excel格式变化时，无法找到正确的列
2. 不同版本的数据文件可能使用不同的列索引
3. 缺乏容错机制和日志记录

**解决方案**：
- 使用智能列名查找
- 支持多种列名和索引
- 添加详细日志记录
- 提供兼容性支持

这样可以确保无论Excel格式如何变化，都能正确获取"门店爆品数"。


---

## ✅ 最终实施方案

### 方案选择：SmartColumnFinder（方案5）

**实施时间**：2025-12-14
**文件位置**：`dashboard_v2.py` 第535-650行

### 核心功能

#### 1. 三层查找机制

```python
class SmartColumnFinder:
    """智能列查找器 - 三层查找机制"""
    
    # 第1层：精确匹配（最可靠）
    EXACT_MAPPINGS = {
        '门店爆品数': ['美团一级分类爆品sku数', '爆品sku数', '爆品数'],
        '门店平均折扣': ['美团一级分类折扣', '折扣'],
        # ... 其他字段
    }
    
    # 第2层：关键词匹配（灵活性）
    KEYWORD_MAPPINGS = {
        '门店爆品数': ['爆品', 'burst', 'hot'],
        '门店平均折扣': ['折扣', 'discount'],
        # ... 其他字段
    }
    
    # 第3层：索引备用（兼容性）
    INDEX_FALLBACK = {
        '门店爆品数': [27, 23],
        '门店平均折扣': [28, 24],
    }
```

#### 2. 智能查找方法

```python
@staticmethod
def find_column(df, field_name):
    """智能查找列（三层机制）"""
    # 第1层：精确匹配
    # 第2层：关键词匹配
    # 第3层：索引备用
    pass

@staticmethod
def get_value(df, field_name, aggregation='sum'):
    """获取字段值"""
    col = SmartColumnFinder.find_column(df, field_name)
    if col is None:
        return None
    
    # 按列名或索引获取
    if isinstance(col, str):
        series = df[col]
    else:
        series = df.iloc[:, col]
    
    # 转换为数值类型并聚合
    series = pd.to_numeric(series, errors='coerce')
    
    if aggregation == 'sum':
        return series.sum()
    elif aggregation == 'mean':
        return series.mean()
    elif aggregation == 'first':
        return series.iloc[0] if len(series) > 0 else None
    
    return None
```

#### 3. 重构后的代码

**修改前**（危险）：
```python
# 硬编码索引27
if len(category_df.columns) > 27:
    summary['门店爆品数'] = category_df.iloc[:, 27].sum()
elif len(category_df.columns) > 23:
    summary['门店爆品数'] = category_df.iloc[:, 23].sum()
```

**修改后**（安全）：
```python
# 使用SmartColumnFinder三层查找
burst_count = SmartColumnFinder.get_value(category_df, '门店爆品数', aggregation='sum')
if burst_count is not None:
    summary['门店爆品数'] = burst_count

avg_discount = SmartColumnFinder.get_value(category_df, '门店平均折扣', aggregation='mean')
if avg_discount is not None:
    summary['门店平均折扣'] = avg_discount
```

### 优势

- ✅ **立即可用**：不需要修改报告生成脚本
- ✅ **兼容性强**：支持所有历史报告
- ✅ **容错性高**：三层查找机制
- ✅ **易于维护**：集中管理所有映射
- ✅ **详细日志**：易于排查问题
- ✅ **面向未来**：为标准化铺路

---

## 🚀 长期方案：标准化报告格式

### 两步走战略

#### 第1步：SmartColumnFinder（已完成）✅

**目的**：立即解决当前问题
**状态**：✅ 已实施
**文档**：`SmartColumnFinder实施完成报告.md`

#### 第2步：标准化报告格式（计划中）

**目的**：从源头彻底解决问题
**时间**：本周开始，逐步迁移
**文档**：`一劳永逸方案_标准化报告格式.md`

**核心思想**：
1. 创建`report_schema.py`定义标准列名
2. 修改报告生成脚本使用标准列名
3. 添加元数据工作表
4. Dashboard自动检测报告格式
5. 逐步迁移到标准格式

**最终状态**：
- 报告生成端：使用标准列名
- Dashboard读取端：直接按列名读取
- 完全消除硬编码索引
- 一劳永逸

---

## 📊 测试验证

### 测试步骤

1. **启动Dashboard**
   ```bash
   python dashboard_v2.py
   ```

2. **上传数据并查看日志**
   - 上传本店原始数据
   - 查看控制台日志

3. **预期日志输出**

   **场景1：精确匹配成功**
   ```
   ✅ 精确匹配: 门店爆品数 -> 美团一级分类爆品sku数
   ```

   **场景2：关键词匹配成功**
   ```
   ✅ 关键词匹配: 门店爆品数 -> 爆品sku数
   ```

   **场景3：索引备用成功**
   ```
   ✅ 索引备用: 门店爆品数 -> 第27列(美团一级分类爆品sku数)
   ```

4. **验证单店视图**
   - 打开"本店数据看板"TAB
   - 检查"门店爆品数"卡片
   - 数值应该正确（不是0）

5. **验证对比视图**
   - 上传竞对数据
   - 开启"对比模式"
   - 选择竞对门店
   - 检查"门店爆品数"对比卡片
   - 应该显示正确的对比数据

---

## 📝 总结

### 问题根源

硬编码索引导致：
- Excel列顺序变化 → 数据错位
- 新增/删除列 → 索引失效
- 不同数据源 → 格式不一致
- 维护困难 → 难以追踪

### 解决方案

**短期**：SmartColumnFinder三层查找机制
- 精确匹配 → 最可靠
- 关键词匹配 → 灵活性
- 索引备用 → 兼容性

**长期**：标准化报告格式
- 定义标准列名
- 修改报告生成
- 添加元数据工作表
- 完全消除硬编码

### 成果

- ✅ 立即解决了当前问题
- ✅ 提高了系统稳定性
- ✅ 改善了可维护性
- ✅ 为未来标准化铺路

**这是一个立即可用且面向未来的解决方案！** 🚀
